#include<16F877.h>
#use delay(clock=4000000)
#fuses NOWDT,XT,NOPROTECT,NOLVP
#define use_port_kbd TRUE
#include <C:\Users\valerio\Desktop\Entrenador UPC\CCS\4-Generador de frecuencia\Librerias\LCD_PORTC.C> //Incluimos libreria para Display
#include <stdio.h>
#include <math.h>
#use standard_io(a)

//Definiciones
#define DIGI_MAX 4          //Numero de digitos maximos 5.
#DEFINE salida PIN_A0  //Definimos pin de salid de nuestro generador de f

//**variables globales**
int cont=0,cont_2=0,cont_3=0,posicion=0,estado=0; //variables tipo entera 8 bits (desde 0 a 254)

char pulsadoo,free_individual[DIGI_MAX];    //variable tipo char, contiene el codigo ascii del caracter a guardar
int16 aux=0,free=0,pulso=0;          //variablesde tipo intero de 16 bits(desde 0 a 65535);

//**Prototi funciones**
void refresca_led(void);              //Funcion de actualizar datos de la pantalla LCD alfanumerica
void lectura_teclado(void);           //Funcion que permite leer las teclas que se presionan en el teclado matricial
void_calcula_numero(void);          //junta las 5 pulsaciones de numeros individuales en un numero unico
void reinicia_variables(void);      //Pone cero las variables de entorno

//**Funcion interrupcion**
#int_TIMER1
void TIMER_isr(void)                //Funcion interrupcion Timer1
{
output_toggle(SALIDA);          //Invierte el estado de la salida del generador de frecuencias
set_timer(65535-pulso);          //Recarga el timer con el valor del pulso deseado
}

//**Funcion refresco display**

void refresca_lcd(void)          //Funcion refresca display alfanumerico
{
switch(cont_2){
    case 0:                                        //caso 0
    printf(led_put,"\fFree:%Lu(Hz)\nIntro:_",free);//Ningun digito introducido
    break;

    case 1:
    printf(led_put,"\fFree:%Lu(Hz)\nIntro:%c_\n",free,free_individual[0],); //primer digito introducido
    break;

    case 2:                                                                    //Caso2                                                                                                                        
    printf(led_put,"\fFree:%Lu(Hz)\nIntro:%c%c_\n",free,free_individual[0],free_individual[1]);    //1° y 2° introducidos
    break;                                                                     //Termina la funcion

    case 3:                                                                    //Caso2                                                                                                                        
    printf(led_put,"\fFree:%Lu(Hz)\nIntro:%c%c%c_\n",free,free_individual[0],free_indibidual[1],free_individual[2]);    //1°, 2° y 3°
    break;                                                                     //Termina la funcion

    case 4:
    printf(led_put,"\fFree:%Lu(Hz)\nIntro:%c%c%c%c_\n",free,free_individual[0],free_indibidual[1],free_individual[2],free_individual[3]);    //1°, 2°, 3° y 4
    break;                                                                     //Termina la funcion

    default:

    printf(lcd_putc,"\fError!"); //muestra error por pantalla
    delay_ms(250);
    delay_ms(250);
    delay_ms(250);
    delay_ms(250);
    reinicia_variables();            //Reinicia las variables
    break;   //Termina la funcion

        
    
    }
    
}//Fin refresca_lcd

//**Funcion principal**

void main(void)
{
//Carga de funciones
lcd_init();                    //Carga la funcion del display alfanumerico
kbd_init()                     //Carga la funcion del teclado matricial
PORT_B_PULLUPS(TRUE);          //Utilizamos las resistencias de pull_up puerto B

printf(led_putc,"\fGenerador\nde funciones");        //Mensaje de bienvenida
delay_ms(255);
delay_ms(250);
delay_ms(250);
delay_ms(250);
refresca_lcd();                 //Refresca el display

reinicia_variables();           //Ponemos las variables a cero

setup_timer_1(T1_internal|T1_DIV_BY_1);          //iniciamos Timer 1, Oscilador interno y preescalar por 1

disable_interrupts8int_timer1);             //No habilitamos las interrupciones del timer 1
enable_interrupts(global);              //Si habilitamos las interrupciones globales

while(1){
    if(estado==0)lectura_teclado();     //Estado 0, leemos teclado matricial
    else if(estado==1)calcula_numero(); //Estado 1, une los diferentes numeros individuales
    else if(estado==2){reinicia_variables(); //Estado 2, reinicia las variables
                refresca_lcd()};            //Refrescamos display

    else delay_us(1);                       //Esperamos 1 us

    }//fin_while

}//fin main

//Funciones

void_lectura_teclado(void)              //Funciones lectura teclado matricial
{
    pulsado=kbd_getc();                //Captura de la pulsacion y guardado para posteriormente verificar
                                        //si es correcta la pulsacion dada
if(cont_2==DIGI_MAX){estado=1;refresca_lcd();}        //Verificamos si es la ultima pulsaciony cambiamos de estado si es asi
else if((pulsado=='0')||(pulsado=='1')||(pulsado=='2')||(pulsado=='3')||(pulsado=='4')||(pulsado=='5')(pulsado=='6')||(pulsado=='7')||(pulsado=='8')||
(pulsado=='9'))                 
                    //Filtramos para comprobar que sea un nuevo compredido entre el 1 y el 9
    {
    free_individual[cont_2=pulsado;]        //Guardamos el dato en el vector de frecuencias individuales
    cont_2++;
    refresca_lcd();

    }

else if(pulsado=='*'){if(cont_2!=0){cont_2--;refresca_lcd();}//Filtramos para comprobar que se ha pulsado la tecla"*"y retrocedemos
                                                            //un digito
else if(pulsado=='#'){estado=1;refresca_lcd();}        //Filtramos para comprobar que se ha pulsado la tecla"#"y retrocedemos
                                                        //al siguiente estado

else delay_us(1);                                        //Pulsamos lus


}

void calcula_numero(void)    //Calcular frecuencia a partir de pulsaciones individuales
{
    posicion=1;        //Iniciamos las variables para ser el calculo
    aux=frec;        //Guardamos en la variable auxiliar la frecuencia anterior
    frec=0;        //ponemos a cero la frecuencia
    for (cont_3=0;cont_3<DIG_MAX;con_3++)    //REcorrido desde cero a digi_max=5 para colocar en lugar correspondiente
                                                //cada digito individual
    {
    frec+=(frec_individual[cont_3]-48)*(pow(10,(DIG_MAX-posicion-(DIGI_MAX-cont_2))));    //Formula para calculo de la posicion
    pisicion++;
    frec_individual[cont_3]=48;    //Inicializamos vector free_individual; Codigo ascii(48)=0
estado=2;                            //Cambiamos el estado
if(frec==0){disable_interrupts(int_timer1);    //Si la frecuencia es cero paramos la salida
    output_low(SALIDA);}        //Colocamos la salida a nivel logico 0
                                //Filtramos para que la frecuencia seleccionada este entre 8 y 7KHz

else if((8<=frec)&&(frec<=7000)){pulso=(500000 free);        //10. 10°62 Pasar a uS y hacemos dos semiperiodos
                    set_timer(65535-pulso);                    //Iiniciamos el conteo del timer 1
                    enable_interrupts(int_timer1);}            //Habilitamos las interrupciones
else {frc==aux;                                        //Devolvemos la frecuencia almacenada en al variable axiliar

    }
}


    



